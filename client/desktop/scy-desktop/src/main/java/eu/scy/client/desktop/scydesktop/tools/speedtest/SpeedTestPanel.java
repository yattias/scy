/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package eu.scy.client.desktop.scydesktop.tools.speedtest;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;

/**
 *
 * @author sikken
 */
public class SpeedTestPanel extends javax.swing.JPanel {

    /** Creates new form SwingSpeedTestPanel */
    public SpeedTestPanel() {
        initComponents();
        startFrameRateCounter();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
   // <editor-fold defaultstate="collapsed" desc="Generated Code">
   private void initComponents() {

      continousRepaintCheckBox = new javax.swing.JCheckBox();
      gcButton = new javax.swing.JButton();

      continousRepaintCheckBox.setText("Continous repaint");
      continousRepaintCheckBox.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            continousRepaintCheckBoxActionPerformed(evt);
         }
      });

      gcButton.setText("GC");
      gcButton.addActionListener(new java.awt.event.ActionListener() {
         public void actionPerformed(java.awt.event.ActionEvent evt) {
            gcButtonActionPerformed(evt);
         }
      });

      org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(layout.createSequentialGroup()
            .add(147, 147, 147)
            .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
               .add(gcButton)
               .add(continousRepaintCheckBox))
            .addContainerGap(142, Short.MAX_VALUE))
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
         .add(layout.createSequentialGroup()
            .addContainerGap()
            .add(continousRepaintCheckBox)
            .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
            .add(gcButton)
            .addContainerGap(240, Short.MAX_VALUE))
      );
   }// </editor-fold>

    private void gcButtonActionPerformed(java.awt.event.ActionEvent evt)
    {
       runtime.gc();
    }

    private void continousRepaintCheckBoxActionPerformed(java.awt.event.ActionEvent evt)
    {
       continousRepaint = continousRepaintCheckBox.isSelected();
    }


   // Variables declaration - do not modify
   private javax.swing.JCheckBox continousRepaintCheckBox;
   private javax.swing.JButton gcButton;
   // End of variables declaration
   private final int labelXPos = 10;
   private final int valueXPos = 70;
   private final int labelYPos = 20;
   private final int stepYPos = 17;
   private final double megaByte = 1024 * 1024;
   private int paintCounter = 0;
   private FrameRateMonitor frameRateMonitor;
   private Runtime runtime = Runtime.getRuntime();
   private boolean continousRepaint = false;

   private class FrameRateMonitor implements Runnable
   {

      private final long sleepTime = 1000;
      private int frameRate = 0;
      private int lastPaintCounter = 0;

      @Override
      public void run()
      {
         while (true)
         {
            try
            {
               Thread.sleep(sleepTime);
            }
            catch (InterruptedException ex)
            {
            }
            frameRate = paintCounter - lastPaintCounter;
            lastPaintCounter = paintCounter;
            repaint();
         }
      }
   }
   @Override
   protected void paintComponent(Graphics grphcs)
   {
      super.paintComponent(grphcs);
      ++paintCounter;
      grphcs.setColor(Color.YELLOW);
      grphcs.fillRect(0, 0, getWidth(), getHeight());
      grphcs.setColor(Color.BLACK);
      int y = labelYPos;
      paintValue(grphcs, y, "size:", "" + getWidth() + "*" + getHeight());
      y += stepYPos;
      paintValue(grphcs, y, "min:", getMinimumSize());
      y += stepYPos;
      paintValue(grphcs, y, "max:", getMaximumSize());
      y += stepYPos;
      paintValue(grphcs, y, "pref:", getPreferredSize());
      y += stepYPos;
      paintValue(grphcs, y, "count:", "" + paintCounter);
      y += stepYPos;
      paintValue(grphcs, y, "fps:", "" + frameRateMonitor.frameRate);
      y += stepYPos;
      paintValue(grphcs, y, "free m:", toMegaBytes(runtime.freeMemory()));
      y += stepYPos;
      paintValue(grphcs, y, "total m:", toMegaBytes(runtime.totalMemory()));
      y += stepYPos;
      paintValue(grphcs, y, "max m:", toMegaBytes(runtime.maxMemory()));
      if (continousRepaint)
      {
         repaint();
      }
   }

   private void paintValue(Graphics grphcs, int y, String label, String value)
   {
      grphcs.drawString(label, labelXPos, y);
      grphcs.drawString(value, valueXPos, y);
   }

   private void paintValue(Graphics grphcs, int y, String label, Dimension size)
   {
      paintValue(grphcs, y, label, "" + size.width + "*" + size.height);
   }

   private String toMegaBytes(long value)
   {
      double mb = value / megaByte;
      return String.format("%4.1f", mb);
   }

   private void startFrameRateCounter()
   {
      frameRateMonitor = new FrameRateMonitor();
      new Thread(frameRateMonitor).start();
   }

   public void setContinousRepaint(boolean continousRepaint)
   {
      this.continousRepaint = continousRepaint;
   }

}
